\contentsline {lstlisting}{\numberline {2.1}A function which adds an integer value \lstinline [mathescape]{v} to the end of a linked list.}{15}{lstlisting.2.1}%
\contentsline {lstlisting}{\numberline {2.2}Ghidra decompilation of the code presented in Listing \ref {code:decompilation-original}. The decompilation is take as-is and has not modified in any way.}{15}{lstlisting.2.2}%
\contentsline {lstlisting}{\numberline {2.3}Ghidra decompilation of the code presented in Listing \ref {code:decompilation-original}. The decompilation has been modified by renaming variabled and changing data types, based on educated guesses.}{15}{lstlisting.2.3}%
\contentsline {lstlisting}{\numberline {2.4}ltrace (``a library call tracer'') output of an obfuscated crackme. One can observe a length check in the first execution, and different output when an input of the expected length is provided.}{17}{lstlisting.2.4}%
\contentsline {lstlisting}{\numberline {2.5}A trivial code example of a function taking a one-byte argument and giving different outputs to \lstinline [mathescape]{stdout}, based on that argument. The example is meant to showcase \gls {SE}. A visual representation of symbolically executing this piece of code can be seen in Figure \ref {fig:se}.}{18}{lstlisting.2.5}%
\contentsline {lstlisting}{\numberline {2.6}VEX \gls {IR} corresponding to the \lstinline [mathescape]{push rbp; mov rbp, rsp} instruction sequence in Intel x86\_64. Each machine instruction is split into muliple, transparent, VEX statements. Each original machine instruction is delimited by an IMark, which specifies the address of the original instruction, and its length in bytes.}{22}{lstlisting.2.6}%
\contentsline {lstlisting}{\numberline {4.1}Decompilation section of the \lstinline [mathescape]{vmwhere} dispatcher, after variable renaming and retyping. We notice the implementation of the \lstinline [mathescape]{add}, \lstinline [mathescape]{jlz} and \lstinline [mathescape]{push_top} instructions.}{31}{lstlisting.4.1}%
\contentsline {lstlisting}{\numberline {4.2}x86\_64 disassembly of the \lstinline [mathescape]{vmcastle} dispatcher. The function handler corresponding to the current opcode is indirectly called through the register \lstinline [mathescape]{RDX}.}{32}{lstlisting.4.2}%
\contentsline {lstlisting}{\numberline {4.3}Stack-based implementation of a simple \lstinline [mathescape]{add} instruction in the \lstinline [mathescape]{vmwhere} architecture.}{33}{lstlisting.4.3}%
\contentsline {lstlisting}{\numberline {4.4}Register-based implementation of a simple \lstinline [mathescape]{add} instruction in the \lstinline [mathescape]{vmcastle} architecture.}{33}{lstlisting.4.4}%
\contentsline {lstlisting}{\numberline {4.5}Partial result of symbolically executing a function handler in Miasm. We notice the state change in core registers such as \lstinline [mathescape]{RDX}, flag changes, as well as changes in memory. The output is clearly convoluted and not easy to read.}{34}{lstlisting.4.5}%
\contentsline {lstlisting}{\numberline {4.6}A cleaned-up result of symbolically executing the same function handler as in Listing \ref {lst:miasm0}. We only chose to display the change in relevant registers and memory locations. Additionally, we introduced labels for better clarity.}{34}{lstlisting.4.6}%
\contentsline {lstlisting}{\numberline {4.7}A minimal angr code sample. We load a program into \lstinline [mathescape]{p}, create a simulation manager, symbolically execute the program until we reach the desired address \lstinline [mathescape]{0xcafebabe}, and finally print the input which determined this execution path.}{37}{lstlisting.4.7}%
\contentsline {lstlisting}{\numberline {4.8}Implementation of an Archinfo module extension for the \lstinline [mathescape]{vmwhere} sample. A list of registers, bit-width, endian-ness and module name are explicitly specified.}{38}{lstlisting.4.8}%
\contentsline {lstlisting}{\numberline {4.9}Implementation of a conditional jump instruction, as part of the lifter module.}{40}{lstlisting.4.9}%
\contentsline {lstlisting}{\numberline {4.10}A short example of SimProcedure implementing a write instruction.}{41}{lstlisting.4.10}%
\contentsline {lstlisting}{\numberline {4.11}Section of the a config file used as input for the \lstinline [mathescape]{arch-genesis} tool. The section contains a partial list of instructions (opcodes), loader details, as well as information essential for the syscall calling convention.}{42}{lstlisting.4.11}%
\contentsline {lstlisting}{\numberline {4.12}Disassembly from a section of bytecode extracted from the \lstinline [mathescape]{vmcastle} sample. The disassembler itself is generated with the \lstinline [mathescape]{arch-genesis} tool.}{43}{lstlisting.4.12}%
\contentsline {lstlisting}{\numberline {4.13}Disassembly of \lstinline [mathescape]{vmwhere} bytecode, which performs a bitwise-xor operation on the top two values on top of the stack, and then a bitwise-or operation on the previous result, and the value at the bottom of the stack.}{45}{lstlisting.4.13}%
\contentsline {lstlisting}{\numberline {4.14}BNF Grammar of the vmwhere bytecode syntax.}{46}{lstlisting.4.14}%
\contentsline {lstlisting}{\numberline {4.15}BNF Grammar of the vmcastle bytecode syntax.}{48}{lstlisting.4.15}%
\contentsline {lstlisting}{\numberline {4.16}\raggedright Cleaned-up decompilation, extracted from Ghidra, of the instruction handler number $111$ from the \lstinline [mathescape]{vmwhere} embedded \gls {VM}. It performs a conditional jump, based on the value of the \lstinline [mathescape]{AC} register.}{51}{lstlisting.4.16}%
\contentsline {lstlisting}{\numberline {4.17}\raggedright Python code which lifts bytecode encoding the conditional jump instruction from Listing \ref {lst:cond_jmp} into VEX IR.}{51}{lstlisting.4.17}%
