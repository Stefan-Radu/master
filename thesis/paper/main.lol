\contentsline {lstlisting}{\numberline {2.1}A function which adds an integer value \lstinline [mathescape]{v} to the end of a linked list.}{12}{lstlisting.2.1}%
\contentsline {lstlisting}{\numberline {2.2}Ghidra decompilation of the code presented in Listing \ref {code:decompilation-original}. The decompilation is take as-is and has not modified in any way.}{12}{lstlisting.2.2}%
\contentsline {lstlisting}{\numberline {2.3}Ghidra decompilation of the code presented in Listing \ref {code:decompilation-original}. The decompilation has been modified by renaming variabled and changing data types, based on educated guesses.}{12}{lstlisting.2.3}%
\contentsline {lstlisting}{\numberline {2.4}ltrace (``a library call tracer'') output of an obfuscated crackme. One can observe a length check in the first execution, and different output when an input of the expected length is provided.}{14}{lstlisting.2.4}%
\contentsline {lstlisting}{\numberline {2.5}A trivial code example of a function taking a one-byte argument and having different output to \lstinline [mathescape]{stdout}, based on that argument. The example is meant to showcase \gls {SE}. A visual representation of symbolically executing this piece of code can be seen in Figure \ref {fig:se}.}{15}{lstlisting.2.5}%
\contentsline {lstlisting}{\numberline {4.1}Decompilation section of the \lstinline [mathescape]{vmwhere} dispatcher, after variable renaming and retyping. We notice the implementation of the \lstinline [mathescape]{add}, \lstinline [mathescape]{jlz} and \lstinline [mathescape]{push_top} instructions.}{26}{lstlisting.4.1}%
\contentsline {lstlisting}{\numberline {4.2}x86\_64 disassembly of the \lstinline [mathescape]{vmcastle} dispatcher. The function handler corresponding to the current opcode is indirectly called through the register \lstinline [mathescape]{RDX}.}{27}{lstlisting.4.2}%
\contentsline {lstlisting}{\numberline {4.3}Stack-based implementation of a simple \lstinline [mathescape]{add} instruction in the \lstinline [mathescape]{vmwhere} architecture.}{28}{lstlisting.4.3}%
\contentsline {lstlisting}{\numberline {4.4}Register-based implementation of a simple \lstinline [mathescape]{add} instruction in the \lstinline [mathescape]{vmcastle} architecture.}{28}{lstlisting.4.4}%
\contentsline {lstlisting}{\numberline {4.5}Partial result of symbolically executing a function handler in Miasm. We notice the state change in core registers such as \lstinline [mathescape]{RDX}, flag changes, as well as changes in memory.}{29}{lstlisting.4.5}%
\contentsline {lstlisting}{\numberline {4.6}A cleaned-up result of symbolically executing the same function handler as in Listing \ref {lst:miasm0}. We only chose to display the change in relevant registers and memory locations. Additionally, we introduced labels for better clarity.}{29}{lstlisting.4.6}%
\contentsline {lstlisting}{\numberline {4.7}A minimal angr code sample. We load a program into \lstinline [mathescape]{p}, create a simulation manager, symbolically execute the program until we reach the desired address \lstinline [mathescape]{0xcafebabe}, and finally print the input which determined this execution path.}{32}{lstlisting.4.7}%
\contentsline {lstlisting}{\numberline {4.8}Implementation of an Archinfo module extension for the \lstinline [mathescape]{vmwhere} sample. A list of registers, bit-width, endian-ness and module name are explicitly specified.}{33}{lstlisting.4.8}%
\contentsline {lstlisting}{\numberline {4.9}Implementation of a conditional jump instruction, as part of the lifter module.}{35}{lstlisting.4.9}%
\contentsline {lstlisting}{\numberline {4.10}A short example of SimProcedure implementing a write instruction.}{36}{lstlisting.4.10}%
\contentsline {lstlisting}{\numberline {4.11}Section of the a config file used as input for the \lstinline [mathescape]{arch-genesis} tool. The section contains a partial list of instructions (opcodes), loader details, as well as information essential for the syscall calling convention.}{37}{lstlisting.4.11}%
\contentsline {lstlisting}{\numberline {4.12}Disassembly from a section of bytecode extracted from the \lstinline [mathescape]{vmcastle} sample. The disassembler itself is generated with the \lstinline [mathescape]{arch-genesis} tool.}{38}{lstlisting.4.12}%
\contentsline {lstlisting}{\numberline {4.13}Disassembly of \lstinline [mathescape]{vmwhere} bytecode, which performs a bitwise-xor operation on the top two values on top of the stack, and then a bitwise-or operation on the previous result, and the value at the bottom of the stack.}{40}{lstlisting.4.13}%
\contentsline {lstlisting}{\numberline {4.14}\raggedright Cleaned-up decompilation, extracted from Ghidra, of the instruction handler number $111$ from the \lstinline [mathescape]{vmwhere} embedded \gls {VM}. It performs a conditional jump, based on the value of the \lstinline [mathescape]{AC} register.}{44}{lstlisting.4.14}%
\contentsline {lstlisting}{\numberline {4.15}\raggedright Python code which lifts bytecode encoding the conditional jump instruction from Listing \ref {lst:cond_jmp} into VEX IR.}{44}{lstlisting.4.15}%
