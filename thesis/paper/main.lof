\addvspace {10\p@ }
\addvspace {10\p@ }
\setforeignlanguage {english}
\contentsline {figure}{\numberline {2.1}{\ignorespaces An infamous screenshot of the ransom pop-up which would show up on a system infected by the WannaCry worm \blx@tocontentsinit {0}\cite {wiki_wannacry}.}}{9}{figure.2.1}%
\setforeignlanguage {english}
\contentsline {figure}{\numberline {2.2}{\ignorespaces Visual representation of the path tree resulting from symbolically executing the code in Listing \ref {lst:fizzbuzz}. Each node in the tree represents a conditional. Each edge has a weight associated with the constraint on argument $c$, which would result in taking the respective branch. Blue rectangles show the output for the associated execution path.}}{16}{figure.2.2}%
\addvspace {10\p@ }
\setforeignlanguage {english}
\contentsline {figure}{\numberline {3.1}{\ignorespaces A high-level abstraction of the inner workings of an embedded \gls {VM} interpretor. Execution begins in the VM entry, where context is switched from the native context to the virtualised context. Then a fetch-decode-execute loop follows. Instructions encoded as bytecode are fetched from the memory and then decoded. Control is switched to a corresponding function handler, identified based on the decoded information. This loop is commonly known as the dispatcher, which continues execution until all the bytecode is processed. \blx@tocontentsinit {0}\cite {blazytko2017}}}{20}{figure.3.1}%
\addvspace {10\p@ }
\setforeignlanguage {english}
\contentsline {figure}{\numberline {4.1}{\ignorespaces \gls {CFG} of the \lstinline [mathescape]{vmwhere} \gls {VM} interpretor. The major components, such as the instruction fetcher, the dispatcher, \gls {VM} handers, as well as the \gls {VM} exit are clearly labelled. The image is generated with the help of the Cutter \gls {RE} tool \blx@tocontentsinit {0}\cite {cutter}.}}{26}{figure.4.1}%
\setforeignlanguage {english}
\contentsline {figure}{\numberline {4.2}{\ignorespaces Diagram describing the components of the angr framework and how they interact. Binary code is loaded by the CLE module. The loaded information is lifted into VEX \gls {IR} through the PyVEX module. Symbolic execution is achieved through the SimEngine. Syscalls and external library calls are relayed through the SimOS module. Claripy takes care of modeling the symbolic state and constraint solving during execution, using an \gls {SMT} solver. Information about the target's architecture is provided to all mentioned components by the Archinfo module. \blx@tocontentsinit {0}\cite {angr} }}{33}{figure.4.2}%
\setforeignlanguage {english}
\contentsline {figure}{\numberline {4.3}{\ignorespaces \gls {CFG} generated with a custom algorithm from the bytecode of the \lstinline [mathescape]{vmwhere} sample.}}{40}{figure.4.3}%
\addvspace {10\p@ }
