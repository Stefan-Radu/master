import bitstring
from pyvex.lifting.util import *
from pyvex.lifting import register

import logging

log = logging.getLogger("vmwhere.lifter")



# This file is autogenerated with the `arch-genesys` tool
# project name: vmwhere
# date: 2024-06-05T17:08:28.242670+00:00


# refferenced types
PTR_TYPE = Type.int_64
STACK_ENTRY_TYPE = Type.int_8


# refferenced registers
IP_REG = 'ip'
BP_REG = 'bp'
SP_REG = 'sp'
SYSNUM_REG = 'sysnum'
IP_AT_SYSCALL_REG = 'ip_at_syscall'
# disassembly functions

def disassemble_generic(self):
    arg = self.rawbits[2:]
    if arg:
        arg = int(self.rawbits[2:], 16)
        arg = hex(arg)
    return self.addr, self.name, [arg], self.description

def disassemble_push(self):
    arg = bytes.fromhex(self.rawbits[2:])
    return self.addr, self.name, [arg], self.description

def disassemble_jmp(self):
    arg = int(self.rawbits[2:], 16)
    if arg & (0x8000):
        offset = arg - 0xffff - 1
    else:
        offset = arg
    jmp = self.addr + 3 + offset
    return self.addr, self.name, [hex(jmp), jmp, offset], self.description


###################################################
# architecture instructions implementation in VEX #
###################################################

class Instruction_EXIT(Instruction):
    bin_format = '00000000'
    name = 'exit'
    description = 'Just exit'

    def compute_result(self, *args):
        # assert(self.last_instruction == True)
        self.jump(None, self.constant(self.addr, PTR_TYPE), jumpkind=JumpKind.Exit) 

    def disassemble(self):
        return disassemble_generic(self)

    def parse(self,bitstream):
        self.last_instruction = False
        data = Instruction.parse(self, bitstream)
        try:
            bitstream.peek(8)
        except bitstring.ReadError:
            # We ran off the end!
            self.last_instruction = True
        return data 
    
class Instruction_ADD(Instruction):
    bin_format = '00000001'
    name = 'add'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        a = self.load(sp - 1, STACK_ENTRY_TYPE)
        b = self.load(sp - 2, STACK_ENTRY_TYPE)
        b = b + a
        self.store(b, sp - 2)
        self.put(sp - 1, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_SUB(Instruction):
    bin_format = '00000010'
    name = 'sub'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        a = self.load(sp - 1, STACK_ENTRY_TYPE)
        b = self.load(sp - 2, STACK_ENTRY_TYPE)
        b = b - a
        self.store(b, sp - 2)
        self.put(sp - 1, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_AND(Instruction):
    bin_format = '00000011'
    name = 'and'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        a = self.load(sp - 1, STACK_ENTRY_TYPE)
        b = self.load(sp - 2, STACK_ENTRY_TYPE)
        b = b & a
        self.store(b, sp - 2)
        self.put(sp - 1, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_OR(Instruction):
    bin_format = '00000100'
    name = 'or'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        a = self.load(sp - 1, STACK_ENTRY_TYPE)
        b = self.load(sp - 2, STACK_ENTRY_TYPE)
        b = b | a
        self.store(b, sp - 2)
        self.put(sp - 1, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_XOR(Instruction):
    bin_format = '00000101'
    name = 'xor'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        a = self.load(sp - 1, STACK_ENTRY_TYPE)
        b = self.load(sp - 2, STACK_ENTRY_TYPE)
        b = b ^ a
        self.store(b, sp - 2)
        self.put(sp - 1, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_SHL(Instruction):
    bin_format = '00000110'
    name = 'shl'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        a = self.load(sp - 1, STACK_ENTRY_TYPE)
        b = self.load(sp - 2, STACK_ENTRY_TYPE)
        b = b << (a & 0x1f)
        self.store(b, sp - 2)
        self.put(sp - 1, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_SHR(Instruction):
    bin_format = '00000111'
    name = 'shr'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        a = self.load(sp - 1, STACK_ENTRY_TYPE)
        b = self.load(sp - 2, STACK_ENTRY_TYPE)
        b = b >> (a & 0x1f)
        self.store(b, sp - 2)
        self.put(sp - 1, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_READ(Instruction):
    bin_format = '00001000'
    name = 'read'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        self.put(sp + 1, SP_REG)
        self.put(self.constant(0, PTR_TYPE), SYSNUM_REG)
        dst = self.constant(self.addr + 1, PTR_TYPE)
        self.jump(None, dst, jumpkind=JumpKind.Syscall) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_WRITE(Instruction):
    bin_format = '00001001'
    name = 'write'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        self.put(sp - 1, SP_REG)
        self.put(self.constant(1, PTR_TYPE), SYSNUM_REG)
        dst = self.constant(self.addr + 1, PTR_TYPE)
        self.jump(None, dst, jumpkind=JumpKind.Syscall) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_PUSH(Instruction):
    bin_format = '00001010xxxxxxxx'
    name = 'push'
    description = ''

    def compute_result(self, *args):
        x = self.constant(int(self.data['x'], 2), STACK_ENTRY_TYPE)
        sp = self.get(SP_REG, PTR_TYPE)
        self.store(x, sp)
        self.put(sp + 1, SP_REG) 

    def disassemble(self):
        return disassemble_push(self)

    
class Instruction_JLZ(Instruction):
    bin_format = '00001011xxxxxxxxxxxxxxxx'
    name = 'jlz'
    description = ''

    def compute_result(self, *args):
        jump_offset = int(self.data['x'], 2)
        dst = self.constant(self.addr + 3 + jump_offset, Type.int_16)

        sp = self.get(SP_REG, PTR_TYPE)
        top = self.load(sp - 1, STACK_ENTRY_TYPE).signed
        zero = self.constant(0, STACK_ENTRY_TYPE)

        self.jump(top < zero, dst) 

    def disassemble(self):
        return disassemble_jmp(self)

    
class Instruction_JZ(Instruction):
    bin_format = '00001100xxxxxxxxxxxxxxxx'
    name = 'jz'
    description = ''

    def compute_result(self, *args):
        jump_offset = int(self.data['x'], 2)
        dst = self.constant(self.addr + 3 + jump_offset, Type.int_16)

        sp = self.get(SP_REG, PTR_TYPE)
        top = self.load(sp - 1, STACK_ENTRY_TYPE).signed
        zero = self.constant(0, STACK_ENTRY_TYPE)

        self.jump(top == zero, dst) 

    def disassemble(self):
        return disassemble_jmp(self)

    
class Instruction_JMP(Instruction):
    bin_format = '00001101xxxxxxxxxxxxxxxx'
    name = 'jmp'
    description = ''

    def compute_result(self, *args):
        jump_offset = int(self.data['x'], 2)
        dst = self.constant(self.addr + 3 + jump_offset, Type.int_16)
        self.jump(None, dst) 

    def disassemble(self):
        return disassemble_jmp(self)

    
class Instruction_POP(Instruction):
    bin_format = '00001110'
    name = 'pop'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        self.put(sp - 1, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_PUSHSTK(Instruction):
    bin_format = '00001111'
    name = 'pushstk'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        top = self.load(sp - 1, STACK_ENTRY_TYPE)
        self.store(top, sp)
        self.put(sp + 1, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_REV(Instruction):
    bin_format = '00010000xxxxxxxx'
    name = 'rev'
    description = ''

    def compute_result(self, *args):
        offset = int(self.data['x'], 2)
        sp = self.get(SP_REG, PTR_TYPE)
        bp = self.get(BP_REG, PTR_TYPE)
        for i in range(offset // 2):
            b = self.load(sp + i - offset, STACK_ENTRY_TYPE)
            a = self.load(sp + (~i), STACK_ENTRY_TYPE)
            self.store(a, sp + i - offset)
            self.store(b, sp + (~i))

        self.jump((sp - bp) < self.constant(offset, PTR_TYPE),
                  self.constant(0, PTR_TYPE))
        self.jump(None, self.constant(0, PTR_TYPE), JumpKind.Segfault) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_EXP(Instruction):
    bin_format = '00010001'
    name = 'exp'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        top = self.load(sp - 1, STACK_ENTRY_TYPE)
        for i in range(8):
            self.store(top & 1, sp - 1 + i)
            top = top >> 1
        self.put(sp + 7, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_SQZ(Instruction):
    bin_format = '00010010'
    name = 'sqz'
    description = ''

    def compute_result(self, *args):
        sp = self.get(SP_REG, PTR_TYPE)
        val = self.constant(0, STACK_ENTRY_TYPE)
        for i in range(7, -1, -1):
            x = self.load(sp -i + i, STACK_ENTRY_TYPE)
            val = val << 1 | (x & 1)
        self.store(val, sp - 8)
        self.put(sp - 7, SP_REG) 

    def disassemble(self):
        return disassemble_generic(self)

    
class Instruction_INVALID(Instruction):
    bin_format = 'xxxxxxxx'
    name = 'invalid'
    description = ''

    def compute_result(self, *args):
        log.error("invalid instruction encountered") 

    def disassemble(self):
        return disassemble_generic(self)

    


# The instrs are matched against in this exact order
all_instrs = [
    Instruction_EXIT,    # 1
    Instruction_ADD,    # 2
    Instruction_SUB,    # 3
    Instruction_AND,    # 4
    Instruction_OR,    # 5
    Instruction_XOR,    # 6
    Instruction_SHL,    # 7
    Instruction_SHR,    # 8
    Instruction_READ,    # 9
    Instruction_WRITE,    # 10
    Instruction_PUSH,    # 11
    Instruction_JLZ,    # 12
    Instruction_JZ,    # 13
    Instruction_JMP,    # 14
    Instruction_POP,    # 15
    Instruction_PUSHSTK,    # 16
    Instruction_REV,    # 17
    Instruction_EXP,    # 18
    Instruction_SQZ,    # 19
    Instruction_INVALID,    # 20
    ]

class LifterVMWHERE(GymratLifter):
    instrs = all_instrs

# Tell PyVEX that this lifter exists.
register(LifterVMWHERE, 'vmwhere')


# a simple disassembly function using the lifter
def disassemble(file_path, arch):
    lifter = LifterVMWHERE(arch, 0)

    with open(file_path, 'rb') as f:
        lifter.data = f.read()[3:]

    disassembly = []
    insts = lifter.disassemble()
    for addr, name, args, desc in insts:
        args_str = ", ".join(str(a) for a in args)
        dis_str = f"{addr:#06x}:  {name} {args_str}"
        if desc:
            dis_str += f"| {desc}"
        disassembly.append(dis_str)

    return "\n".join(disassembly)